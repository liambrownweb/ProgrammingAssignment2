## In accordance with the requirements of Assignment 2 of the R Programming course,
## two functions exist here. makeCacheMatrix() creates a caching object with the
## appropriate accessors and mutators to allow easy access to the internal variables.
## The second function, cacheSolve(), accepts an object generated by the makeCacheMatrix
## function and attempts to calculate the inverse of the matrix contained therein.
## If the inverse of the matrix currently within the object has already been calculated,
## cacheSolve() will retrieve and return that cached value rather than recalculating.

## creates a special "matrix" object that can cache its inverse.
makeCacheMatrix <- function(x = matrix()) {
    # Cache_matrix basically functions as a protected structure. The only methods
    # are its accessors and mutators, as can be seen. All calculations are to be
    # done elsewhere.
        ## Allow for easy construction from an existing matrix.
        original_matrix <- x
        ## The cache
        inverse <- NULL
        ## Easy flag to save calculation
        changed_since_inverse <- FALSE
        getMatrix = function() {
            return (original_matrix)
        }
        setMatrix = function(y) {
            if (y != original_matrix) {
                original_matrix <<- y
                ## Assigning a new value to original_matrix, we outdate the cached inverse.
                ## Set our flag to ensure it doesn't get used (could null the cache, but
                ## this is intended to minimize the amount of manipulation).
                changed_since_inverse <<- TRUE
            }
        }
        ## The accessor for the inverse of the matrix. If there's been a change since
        ## it was calculated, NULL is all that comes back. Otherwise return the cache.
        getInverse = function() {
            if (changed_since_inverse) {
                return (NULL)
            } else {                
                return (inverse)
            }
        }
        setInverse = function(y) {
            inverse <<- y
            ## Falsify the changed flag to signify that the cache is up to date.
            changed_since_inverse <<- FALSE
        }
    cache_matrix <- list (
        original_matrix = original_matrix,
        inverse = inverse,
        changed_since_inverse = changed_since_inverse,
        getMatrix = getMatrix,
        setMatrix = setMatrix,
        getInverse = getInverse,
        setInverse = setInverse
        )
    return (cache_matrix)
}


## Computes the inverse of the special "matrix" returned by makeCacheMatrix above. 
## If the inverse has already been calculated and the matrix has not changed, 
## then cacheSolve retrieves the inverse from the cache.

cacheSolve <- function(x = makeCacheMatrix(), ...) {
    ## First we call the getInverse function of the x parameter to check the cache.
    ## Note that x is assumed to be an object of the type created by makeCacheMatrix().
    ## Of course, assigning to x an object of any other type will cause an error.
    inverse <- x$getInverse()
    ## If the result of the cache check is not null, we have a valid and current inverse. 
    ## No need to calculate, just return.
    if (!is.null(inverse)) {
        return (inverse)
    } else {
        ## If the inverse is null, first we'll invert the original matrix, then cache
        ## the inverse, then return the inverse.
        inverse <- solve(x$getMatrix())
        x$setInverse(inverse)
        return (inverse)
    }
}
